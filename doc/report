Московский Авиационный Институт
(Национальный Исследовательский Университет)

Факультет информационных технологий и прикладной математики
Кафедра вычислительной математики и программирования


Лабораторная работа №1 по курсу 
«Операционные системы»
	
ВЗАИМОДЕЙСТВИЕ МЕЖДУ ПРОЦЕССАМИ















Студент: Маношин Виталий Дмитриевич
Группа: М8О–210Б–22
Вариант: 4 
Преподаватель: Соколов Андрей Алексеевич
Оценка: __________ 
Дата: __________
Подпись: __________



Москва, 2023.

Постановка задачи
Цель работы
Целью является приобретение практических навыков в:
    • управлении процессами в ОС;
    • обеспечении обмена данных между процессами посредством каналов.
Задание
Составить и отладить программу на языке С/C++, осуществляющую работу с процессами и взаимодействие между ними в одной из двух операционных систем. В результате работы программа (основной процесс) должен создать для решения задачи один или несколько дочерних процессов. Взаимодействие между процессами осуществляется через системные сигналы/события и/или каналы (pipe).
Пользователь вводит команды вида: «число число число<endline>». Далее эти числа
передаются от родительского процесса в дочерний. Дочерний процесс производит деление
первого числа, на последующие, а результат выводит в файл. Если происходит деление на 0, то
тогда дочерний и родительский процесс завершают свою работу. Проверка деления на 0 должна
осуществляться на стороне дочернего процесса. Числа имеют тип float. Количество чисел может
быть произвольным.
Общие сведения о программе 
Программа скомпилируется из двух файлов main.cpp, child.cpp. В программе используются следующие системные вызовы:
    1. pid_t fork() – создание дочернего процесса.
    2. int execl(const char *filename, char *const argv[], char *const envp[]) – замена образа памяти процесса.
    3. int pipe(int pipefd[2]) – создание неименованного канала для передачи данных между процессами.
    4. int dup2(int oldfd, int newfd) – переназначение файлового дескриптора.
    5. int open(const char *pathname, int flags, mode_t mode) – открытие/создание файла.
    6. int close(int fd) – закрыть файл.
Общий метод и алгоритм решения.
Для реализации поставленной задачи необходимо:
    1. Изучить принципы работы fork, execl, pipe, dup2, open, close.
    2. Написать программу родительского процесса main.cpp, которая:
        a. создает дочерний процесс командой fork;
        b. принимает строки из стандартного потока ввода и пересылает их в pipe.
    3. Написать программы дочернего процесса.
    4. В файле родительского процесса вызывать дочерние и запускать их программы командой execl.
Основные файлы программы
main.cpp:
#include <iostream>
#include <unistd.h>
#include <string.h>
#include <string>
#include <sys/wait.h>
#include <fcntl.h>
#include <vector>

using namespace std;

int main() {
string name;
char c = '#';
write(STDOUT_FILENO, "Enter the name of file: ", 24);
while (c != '\n') {
read(STDIN_FILENO, &c, sizeof(char));
if (c != '\n') {
name += c;
}
}

int fd1[2], fd2[2];
int pipe1 = pipe(fd1), pipe2 = pipe(fd2);
if (pipe1 == -1 || pipe2 == -1) {
write(STDERR_FILENO, "Err creating a pipe", 19);
return 1;
}

int write1 = fd1[1], read1 = fd1[0];
int write2 = fd2[1], read2 = fd2[0];

pid_t pid = fork();
if (pid == -1) {
write(STDERR_FILENO, "Err creating a child process", 28);
return 2;
}
if (pid == 0) {
//child process
close(write1);
close(read2);
int r1 = dup2(read1, STDIN_FILENO), w2 = dup2(write2, STDOUT_FILENO);
if (r1 == -1 || w2 == -1) {
write(STDERR_FILENO, "Err dup2", 8);
return 3;
}
execl("child", "child", name.c_str(), NULL);

write(STDERR_FILENO, "Err child process", 17);
return 4;

}
if (pid > 0) {
//parent process
close(read1);
close(write2);
char c;
while (read(STDIN_FILENO, &c, 1)) {
write(write1, &c, sizeof(c));
}
close(write1);
close(read2);
}

return 0;
}


child.cpp:
#include <iostream>
#include <unistd.h>
#include <vector>
#include <fcntl.h>
#include <string>

using namespace std;

int main(int argc, char* argv[]) {

int file = open(argv[1], O_WRONLY);
if (file == -1) {
write(STDERR_FILENO, "An error occured with opening a file", 37);
return 1;
}

int ft = ftruncate(file, 0);
if (ft == -1) {
write(STDERR_FILENO, "An error occured with clearing a file", 38);
return 2;
}

char c;
string s;
float ans;
bool first = 1;
while (read(STDIN_FILENO, &c, 1)) {
if(c != '\n' && c != ' ') {
s += c;
} else {
if(first) {
first = 0;
ans = stof(s);
} else {
if(stof(s) == float(0)) {
write(STDERR_FILENO, "Err zero", 8);
return 3;
}
ans /= stof(s);
}
s.clear();
if(c == '\n') {
first = 1;
s = to_string(ans); 
for(int i = 0; i < s.size(); ++i) { 
write(file, &s[i], 1);
}
write(file, " ", 1);
s.clear();
}
}
}
return 0;
}

Пример работы
В консоль вводится:
out
3
3 1 2 3
2 1 2
1 1

В файле out будет: 
3.000000
0.500000 
1.000000 
1.000000
Вывод
Данная лабораторная работа позволила более детально разобраться в создании и работе дочерних процессов, «общении» между ними с помощью неименованных каналов pipe и во включении другой программы в работу текущей. Были изучены принципы работы сложных функций printf и scanf, в основе которых лежат функции write и read соответсвенно.
